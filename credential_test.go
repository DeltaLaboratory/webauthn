// Copyright (c) 2019 Faye Amacker. All rights reserved.
// Use of this source code is governed by Apache License 2.0 found in the LICENSE file.

package webauthn

import (
	"bytes"
	"crypto"
	"crypto/ecdsa"
	"crypto/elliptic"
	"crypto/rsa"
	"crypto/x509"
	"math/big"
	"reflect"
	"strings"
	"testing"

	"github.com/fxamacker/cbor"
)

var (
	coseKeyES256 = map[int]interface{}{
		labelKty: coseKeyTypeEllipticCurve,
		labelAlg: COSEAlgES256,
		labelCrv: coseCurveP256,
		labelX:   []byte{0x65, 0xed, 0xa5, 0xa1, 0x25, 0x77, 0xc2, 0xba, 0xe8, 0x29, 0x43, 0x7f, 0xe3, 0x38, 0x70, 0x1a, 0x10, 0xaa, 0xa3, 0x75, 0xe1, 0xbb, 0x5b, 0x5d, 0xe1, 0x08, 0xde, 0x43, 0x9c, 0x08, 0x55, 0x1d},
		labelY:   []byte{0x1e, 0x52, 0xed, 0x75, 0x70, 0x11, 0x63, 0xf7, 0xf9, 0xe4, 0x0d, 0xdf, 0x9f, 0x34, 0x1b, 0x3d, 0xc9, 0xba, 0x86, 0x0a, 0xf7, 0xe0, 0xca, 0x7c, 0xa7, 0xe9, 0xee, 0xcd, 0x00, 0x84, 0xd1, 0x9c},
	}
	publicKeyES256 = &ecdsa.PublicKey{
		Curve: elliptic.P256(),
		X:     big.NewInt(0).SetBytes([]byte{0x65, 0xed, 0xa5, 0xa1, 0x25, 0x77, 0xc2, 0xba, 0xe8, 0x29, 0x43, 0x7f, 0xe3, 0x38, 0x70, 0x1a, 0x10, 0xaa, 0xa3, 0x75, 0xe1, 0xbb, 0x5b, 0x5d, 0xe1, 0x08, 0xde, 0x43, 0x9c, 0x08, 0x55, 0x1d}),
		Y:     big.NewInt(0).SetBytes([]byte{0x1e, 0x52, 0xed, 0x75, 0x70, 0x11, 0x63, 0xf7, 0xf9, 0xe4, 0x0d, 0xdf, 0x9f, 0x34, 0x1b, 0x3d, 0xc9, 0xba, 0x86, 0x0a, 0xf7, 0xe0, 0xca, 0x7c, 0xa7, 0xe9, 0xee, 0xcd, 0x00, 0x84, 0xd1, 0x9c}),
	}
	publicKeyES256PEM = `-----BEGIN PUBLIC KEY-----
MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEZe2loSV3wrroKUN/4zhwGhCqo3Xh
u1td4QjeQ5wIVR0eUu11cBFj9/nkDd+fNBs9ybqGCvfgynyn6e7NAITRnA==
-----END PUBLIC KEY-----
`

	coseKeyPS256 = map[int]interface{}{
		labelKty: coseKeyTypeRSA,
		labelAlg: COSEAlgPS256,
		labelN: []byte{
			0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
			0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
			0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
			0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
			0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
			0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
			0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
			0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
		},
		labelE: []byte{0x00, 0x01, 0x00, 0x01},
	}
	publicKeyPS256 = &rsa.PublicKey{
		N: big.NewInt(0).SetBytes([]byte{
			0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
			0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
			0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
			0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
			0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
			0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
			0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
			0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
		}),
		E: 65537,
	}
	publicKeyPS256PEM = `-----BEGIN PUBLIC KEY-----
MIIBITANBgkqhkiG9w0BAQEFAAOCAQ4AMIIBCQKCAQABAQEBAQEBAQEBAQEBAQEB
AQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEB
AQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEB
AQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEB
AQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEB
AQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEB
AgMBAAE=
-----END PUBLIC KEY-----
`

	coseKeyRS256 = map[int]interface{}{
		labelKty: coseKeyTypeRSA,
		labelAlg: COSEAlgRS256,
		labelN: []byte{
			0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
			0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
			0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
			0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
			0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
			0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
			0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
			0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
		},
		labelE: []byte{0x00, 0x01, 0x00, 0x01},
	}
	publicKeyRS256 = &rsa.PublicKey{
		N: big.NewInt(0).SetBytes([]byte{
			0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
			0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
			0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
			0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
			0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
			0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
			0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
			0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
		}),
		E: 65537,
	}
	publicKeyRS256PEM = `-----BEGIN PUBLIC KEY-----
MIIBITANBgkqhkiG9w0BAQEFAAOCAQ4AMIIBCQKCAQABAQEBAQEBAQEBAQEBAQEB
AQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEB
AQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEB
AQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEB
AQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEB
AQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEB
AgMBAAE=
-----END PUBLIC KEY-----
`

	// incomplete input data
	incompleteKey = map[int]interface{}{
		labelKty: coseKeyTypeEllipticCurve,
		labelAlg: COSEAlgES256,
	}

	// invalid alg data type
	invalidAlg = copyKey(coseKeyES256).modify(labelAlg, "wrong data type")

	// missing alg
	missingAlg = copyKey(coseKeyES256).remove(labelAlg)

	// unsupported alg
	unsupportedAlg = copyKey(coseKeyRS256).modify(labelAlg, -8) // EdDSA

	// invalid kty data type
	invalidKty = copyKey(coseKeyES256).modify(labelKty, "wrong data type")

	// missing kty
	missingKty = copyKey(coseKeyES256).remove(labelKty)

	// mismatch alg + kty
	mismatchAlgKty1 = copyKey(coseKeyES256).modify(labelKty, coseKeyTypeRSA)

	// mismatch alg + kty
	mismatchAlgKty2 = copyKey(coseKeyRS256).modify(labelKty, coseKeyTypeEllipticCurve)

	// invalid curve data type
	invalidCurve = copyKey(coseKeyES256).modify(labelCrv, "wrong data type")

	// missing curve
	missingCurve = copyKey(coseKeyES256).remove(labelCrv).modify(10, 1) // add additional entry to keep map size the same after removing curve entry

	// unsupported curve
	unsupportedCurve = copyKey(coseKeyES256).modify(labelCrv, 4)

	// invalid x data type
	invalidX = copyKey(coseKeyES256).modify(labelX, 1)

	// missing x
	missingX = copyKey(coseKeyES256).remove(labelX).modify(10, 1) // add additional entry to keep map size the same after removing curve entry

	// invalid y data type
	invalidY = copyKey(coseKeyES256).modify(labelY, 1)

	// missing y
	missingY = copyKey(coseKeyES256).remove(labelY).modify(10, 1) // add additional entry to keep map size the same after removing curve entry

	// invalid n data type
	invalidN = copyKey(coseKeyRS256).modify(labelN, 1)

	// missing n
	missingN = copyKey(coseKeyRS256).remove(labelN).modify(10, 1) // add additional entry to keep map size the same after removing curve entry

	// invalid e data type
	invalidE = copyKey(coseKeyRS256).modify(labelE, 1)

	// missing e
	missingE = copyKey(coseKeyRS256).remove(labelE).modify(10, 1) // add additional entry to keep map size the same after removing curve entry
)

type parseCredentialTest struct {
	name             string
	data             []byte
	wantSigAlg       x509.SignatureAlgorithm
	wantPublicKey    crypto.PublicKey
	wantPublicKeyPEM []byte
}

type parseCredentialErrorTest struct {
	name         string
	data         []byte
	wantErrorMsg string
}

var parseCredentialTests = []parseCredentialTest{
	{"ES256", cborMarshal(coseKeyES256), x509.ECDSAWithSHA256, publicKeyES256, []byte(publicKeyES256PEM)},
	{"PS256", cborMarshal(coseKeyPS256), x509.SHA256WithRSAPSS, publicKeyPS256, []byte(publicKeyPS256PEM)},
	{"RS256", cborMarshal(coseKeyRS256), x509.SHA256WithRSA, publicKeyRS256, []byte(publicKeyRS256PEM)},
}

var parseCredentialErrorTests = []parseCredentialErrorTest{
	{"invalid cbor data", []byte("hello"), "credential: failed to unmarshal: EOF"},
	{"incomplete input data", cborMarshal(incompleteKey), "credential of COSE key type 2 and algorithm -7 is not supported"},
	{"invalid alg data type", cborMarshal(invalidAlg), "credential: invalid algorithm"},
	{"missing alg", cborMarshal(missingAlg), "credential: missing algorithm"},
	{"unsupported alg", cborMarshal(unsupportedAlg), "COSE algorithm -8 is not registered"},
	{"invalid kty data type", cborMarshal(invalidKty), "credential: invalid key type"},
	{"missing kty", cborMarshal(missingKty), "credential: missing key type"},
	{"mismatched alg and kty", cborMarshal(mismatchAlgKty1), "credential: COSE key type 3 and algorithm -7 are mismatched"},
	{"mismatched alg and kty", cborMarshal(mismatchAlgKty2), "credential: COSE key type 2 and algorithm -257 are mismatched"},
	{"invalid curve data type", cborMarshal(invalidCurve), "credential: invalid ECDSA curve"},
	{"missing curve", cborMarshal(missingCurve), "credential: missing ECDSA curve"},
	{"unsupported curve", cborMarshal(unsupportedCurve), "credential COSE curve 4 is not supported"},
	{"invalid x data type", cborMarshal(invalidX), "credential: invalid ECDSA x"},
	{"missing x", cborMarshal(missingX), "credential: missing ECDSA x"},
	{"invalid y data type", cborMarshal(invalidY), "credential: invalid ECDSA y"},
	{"missing y", cborMarshal(missingY), "credential: missing ECDSA y"},
	{"invalid n data type", cborMarshal(invalidN), "credential: invalid RSA n"},
	{"missing n", cborMarshal(missingN), "credential: missing RSA n"},
	{"invalid e data type", cborMarshal(invalidE), "credential: invalid RSA e"},
	{"missing e", cborMarshal(missingE), "credential: missing RSA e"},
}

func cborMarshal(itf interface{}) []byte {
	data, err := cbor.Marshal(itf, cbor.EncOptions{Canonical: true})
	if err != nil {
		panic(err)
	}
	return data
}

type coseKey map[int]interface{}

func copyKey(key coseKey) coseKey {
	copy := make(map[int]interface{})
	for k, v := range map[int]interface{}(key) {
		copy[k] = v
	}
	return copy
}

func (key coseKey) modify(k int, v interface{}) coseKey {
	key[k] = v
	return key
}

func (key coseKey) remove(k int) coseKey {
	delete(key, k)
	return key
}

func TestParseCredential(t *testing.T) {
	for _, tc := range parseCredentialTests {
		t.Run(tc.name, func(t *testing.T) {
			credential, rest, err := ParseCredential(tc.data)
			if err != nil {
				t.Fatalf("ParseCredential() returns error %q", err)
			}
			if len(rest) != 0 {
				t.Errorf("ParseCredential() returns rest %v, want empty slice", rest)
			}
			if !bytes.Equal(credential.Raw, tc.data) {
				t.Errorf("credential raw is %v, want %v", credential.Raw, tc.data)
			}
			if credential.Algorithm != tc.wantSigAlg {
				t.Errorf("credential algorithm is %s, want %s", credential.Algorithm, tc.wantSigAlg)
			}
			if !reflect.DeepEqual(credential.PublicKey, tc.wantPublicKey) {
				t.Errorf("credential public key is %v, want %v", credential.PublicKey, tc.wantPublicKey)
			}
			gotPEM, err := credential.MarshalPKIXPublicKeyPEM()
			if err != nil {
				t.Errorf("MarshalPKIXPublicKeyPEM() returns error %q", err)
			}
			if !bytes.Equal(gotPEM, tc.wantPublicKeyPEM) {
				t.Errorf("MarshalPKIXPublicKeyPEM() returns %q, want %q", gotPEM, tc.wantPublicKeyPEM)
			}
		})
	}
}

func TestParseCredentialError(t *testing.T) {
	for _, tc := range parseCredentialErrorTests {
		t.Run(tc.name, func(t *testing.T) {
			if _, _, err := ParseCredential(tc.data); err == nil {
				t.Errorf("parseCredential() returns no error,  want error containing substring %q", tc.wantErrorMsg)
			} else if !strings.Contains(err.Error(), tc.wantErrorMsg) {
				t.Errorf("parseCredential() returns error %q,  want error containing substring %q", err, tc.wantErrorMsg)
			}
		})
	}
}
